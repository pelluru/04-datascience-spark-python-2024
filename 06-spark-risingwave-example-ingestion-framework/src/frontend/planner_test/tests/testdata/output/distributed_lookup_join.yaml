# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: fix https://github.com/risingwavelabs/risingwave/issues/10721
  sql: |
    create table t1 (a int, b int , c int);
    create table t2 (a int, b int , c int);
    create index idx on t2 (a, b) distributed by (a);
    select * from t1 natural join t2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: t1.a = idx.a AND t1.b = idx.b AND t1.c = idx.c, output: [t1.c, t1.b, t1.a], lookup table: idx }
      └─BatchExchange { order: [], dist: UpstreamHashShard(t1.a) }
        └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], distribution: SomeShard }
- id: fix https://github.com/risingwavelabs/risingwave/issues/10721
  sql: |
    create table t1 (a int, b int , c int);
    create table t2 (a int, b int , c int);
    create index idx on t2 (b, a) distributed by (b);
    select * from t1 natural join t2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: t1.b = idx.b AND t1.a = idx.a AND t1.c = idx.c, output: [t1.c, t1.b, t1.a], lookup table: idx }
      └─BatchExchange { order: [], dist: UpstreamHashShard(t1.b) }
        └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], distribution: SomeShard }
- id: fix https://github.com/risingwavelabs/risingwave/issues/10721
  sql: |
    create table t1 (a int, b int , c int);
    create table t2 (a int, b int , c int);
    create index idx on t2 (c, b, a) distributed by (c, b);
    select * from t1 natural join t2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: t1.c = idx.c AND t1.b = idx.b AND t1.a = idx.a, output: [t1.c, t1.b, t1.a], lookup table: idx }
      └─BatchExchange { order: [], dist: UpstreamHashShard(t1.c, t1.b) }
        └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], distribution: SomeShard }
- id: fix https://github.com/risingwavelabs/risingwave/issues/10721
  sql: |
    create table t1 (a int, b int , c int);
    create table t2 (a int, b int , c int);
    create index idx on t2 (c, b, a) distributed by (c, b, a);
    select * from t1 natural join t2;
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchLookupJoin { type: Inner, predicate: t1.c = idx.c AND t1.b = idx.b AND t1.a = idx.a, output: [t1.c, t1.b, t1.a], lookup table: idx }
      └─BatchExchange { order: [], dist: UpstreamHashShard(t1.c, t1.b, t1.a) }
        └─BatchScan { table: t1, columns: [t1.a, t1.b, t1.c], distribution: SomeShard }
