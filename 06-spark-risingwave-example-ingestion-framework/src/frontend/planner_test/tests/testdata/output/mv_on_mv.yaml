# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- id: create_tables
  sql: |
    create table t1(v1 int, v2 int);
    create table t2(v1 real, v2 int, v3 real);
    create materialized view m1 as select v1, v2 from t1 where v1 = 1;
    create materialized view m2 as select v1, v2 from t1 where v2 = 1;
- id: mv_on_mv_join
  before:
  - create_tables
  sql: |
    select m1.v1 as m1v1, m1.v2 as m1v2, m2.v1 as m2v1, m2.v2 as m2v2 from m1 join m2 on m1.v1 = m2.v1;
  stream_plan: |-
    StreamMaterialize { columns: [m1v1, m1v2, m2v1, m2v2, m1.t1._row_id(hidden), m2.t1._row_id(hidden)], stream_key: [m1.t1._row_id, m2.t1._row_id, m1v1], pk_columns: [m1.t1._row_id, m2.t1._row_id, m1v1], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard(m1.v1, m1.t1._row_id, m2.t1._row_id) }
      └─StreamHashJoin { type: Inner, predicate: m1.v1 = m2.v1, output: [m1.v1, m1.v2, m2.v1, m2.v2, m1.t1._row_id, m2.t1._row_id] }
        ├─StreamExchange { dist: HashShard(m1.v1) }
        │ └─StreamTableScan { table: m1, columns: [m1.v1, m1.v2, m1.t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [m1.t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(m1.t1._row_id) }
        └─StreamExchange { dist: HashShard(m2.v1) }
          └─StreamTableScan { table: m2, columns: [m2.v1, m2.v2, m2.t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [m2.t1._row_id], pk: [t1._row_id], dist: UpstreamHashShard(m2.t1._row_id) }
