# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- name: delete with returning
  sql: |
    create table t (a int, b int);
    delete from t returning *, a, a+b;
  logical_plan: |-
    LogicalProject { exprs: [t.a, t.b, t.a, (t.a + t.b) as $expr1] }
    └─LogicalDelete { table: t, returning: true }
      └─LogicalProject { exprs: [t.a, t.b, t._row_id] }
        └─LogicalScan { table: t, columns: [t.a, t.b, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [t.a, t.b, t.a, (t.a + t.b) as $expr1] }
      └─BatchDelete { table: t, returning: true }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: t, columns: [t.a, t.b, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- name: delete with returning constant, should keep `Delete`
  sql: |
    create table t (v int);
    delete from t returning 114514;
  logical_plan: |-
    LogicalProject { exprs: [114514:Int32] }
    └─LogicalDelete { table: t, returning: true }
      └─LogicalProject { exprs: [t.v, t._row_id] }
        └─LogicalScan { table: t, columns: [t.v, t._row_id, t._rw_timestamp] }
  batch_plan: |-
    BatchExchange { order: [], dist: Single }
    └─BatchProject { exprs: [114514:Int32] }
      └─BatchDelete { table: t, returning: true }
        └─BatchExchange { order: [], dist: Single }
          └─BatchScan { table: t, columns: [t.v, t._row_id], distribution: UpstreamHashShard(t._row_id) }
- name: insert with returning agg functions, should not run
  sql: |
    create table t (a int, b int);
    delete from t returning sum(a);
  binder_error: 'Bind error: should not have agg/window in the `RETURNING` list'
- name: distributed delete
  sql: |
    set batch_enable_distributed_dml = true;
    create table t (a int, b int);
    delete from t;
  batch_distributed_plan: |-
    BatchSimpleAgg { aggs: [sum()] }
    └─BatchExchange { order: [], dist: Single }
      └─BatchDelete { table: t }
        └─BatchExchange { order: [], dist: HashShard(t.a, t.b, t._row_id) }
          └─BatchScan { table: t, columns: [t.a, t.b, t._row_id], distribution: UpstreamHashShard(t._row_id) }
