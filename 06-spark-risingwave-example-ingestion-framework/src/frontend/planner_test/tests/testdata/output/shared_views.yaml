# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t1 (x int, y int);
    create view v1 as select x + y as z from t1 where y > 0;
    create view v2 as select x * z as a, y * z as b from t1, v1 where z = x;
    select * from v1, v2 where z = a;
  logical_plan: |-
    LogicalProject { exprs: [$expr1, $expr2, $expr3] }
    └─LogicalFilter { predicate: ($expr1 = $expr2) }
      └─LogicalJoin { type: Inner, on: true, output: all }
        ├─LogicalShare { id: 3 }
        │ └─LogicalProject { exprs: [(t1.x + t1.y) as $expr1] }
        │   └─LogicalFilter { predicate: (t1.y > 0:Int32) }
        │     └─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
        └─LogicalShare { id: 7 }
          └─LogicalProject { exprs: [(t1.x * $expr1) as $expr2, (t1.y * $expr1) as $expr3] }
            └─LogicalFilter { predicate: ($expr1 = t1.x) }
              └─LogicalJoin { type: Inner, on: true, output: all }
                ├─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
                └─LogicalShare { id: 3 }
                  └─LogicalProject { exprs: [(t1.x + t1.y) as $expr1] }
                    └─LogicalFilter { predicate: (t1.y > 0:Int32) }
                      └─LogicalScan { table: t1, columns: [t1.x, t1.y, t1._row_id, t1._rw_timestamp] }
  stream_plan: |-
    StreamMaterialize { columns: [z, a, b, t1._row_id(hidden), t1._row_id#1(hidden), t1._row_id#2(hidden), t1.x(hidden)], stream_key: [t1._row_id, t1._row_id#1, t1._row_id#2, t1.x, z], pk_columns: [t1._row_id, t1._row_id#1, t1._row_id#2, t1.x, z], pk_conflict: NoCheck }
    └─StreamExchange { dist: HashShard($expr1, t1._row_id, t1._row_id, t1._row_id, t1.x) }
      └─StreamHashJoin { type: Inner, predicate: $expr1 = $expr2, output: [$expr1, $expr2, $expr3, t1._row_id, t1._row_id, t1._row_id, t1.x] }
        ├─StreamExchange { dist: HashShard($expr1) }
        │ └─StreamShare { id: 3 }
        │   └─StreamProject { exprs: [(t1.x + t1.y) as $expr1, t1._row_id] }
        │     └─StreamFilter { predicate: (t1.y > 0:Int32) }
        │       └─StreamTableScan { table: t1, columns: [t1.x, t1.y, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
        └─StreamExchange { dist: HashShard($expr2) }
          └─StreamProject { exprs: [(t1.x * $expr1) as $expr2, (t1.y * $expr1) as $expr3, t1._row_id, t1._row_id, t1.x] }
            └─StreamHashJoin { type: Inner, predicate: t1.x = $expr1, output: [t1.x, t1.y, $expr1, t1._row_id, t1._row_id] }
              ├─StreamExchange { dist: HashShard(t1.x) }
              │ └─StreamTableScan { table: t1, columns: [t1.x, t1.y, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
              └─StreamExchange { dist: HashShard($expr1) }
                └─StreamShare { id: 3 }
                  └─StreamProject { exprs: [(t1.x + t1.y) as $expr1, t1._row_id] }
                    └─StreamFilter { predicate: (t1.y > 0:Int32) }
                      └─StreamTableScan { table: t1, columns: [t1.x, t1.y, t1._row_id], stream_scan_type: ArrangementBackfill, stream_key: [t1._row_id], pk: [_row_id], dist: UpstreamHashShard(t1._row_id) }
